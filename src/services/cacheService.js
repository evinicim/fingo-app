/**
 * ============================================
 * SERVIÃ‡O DE CACHE - cacheService.js
 * ============================================
 * 
 * Sistema de cache em duas camadas para otimizar performance da aplicaÃ§Ã£o FinGo.
 * Implementa cache em memÃ³ria (rÃ¡pido) e cache persistente (AsyncStorage).
 * 
 * Funcionalidades:
 * - Cache em memÃ³ria para acesso instantÃ¢neo
 * - Cache persistente para dados entre sessÃµes
 * - InvalidaÃ§Ã£o automÃ¡tica por tempo
 * - PrÃ©-carregamento de dados essenciais
 * - Cache especÃ­fico por usuÃ¡rio
 * 
 * @author Equipe FinGo
 * @version 1.0.0
 */

// ServiÃ§o de cache para otimizar carregamento
import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * DuraÃ§Ã£o padrÃ£o do cache em milissegundos (5 minutos)
 */
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos em milissegundos

/**
 * Cache em memÃ³ria para acesso instantÃ¢neo aos dados
 * Mais rÃ¡pido que AsyncStorage, mas perdido ao fechar o app
 */
// Cache em memÃ³ria (mais rÃ¡pido que AsyncStorage)
const memoryCache = new Map();

/**
 * Gera chave Ãºnica de cache baseada na chave e ID do usuÃ¡rio
 * @param {string} key - Chave base do cache
 * @param {string|null} userId - ID do usuÃ¡rio (opcional)
 * @returns {string} Chave Ãºnica de cache
 */
// Gerar chave de cache
const getCacheKey = (key, userId = null) => {
  return userId ? `cache_${userId}_${key}` : `cache_${key}`;
};

/**
 * Salva dados no cache (memÃ³ria + AsyncStorage)
 * @param {string} key - Chave do cache
 * @param {any} data - Dados a serem salvos
 * @param {string|null} userId - ID do usuÃ¡rio (opcional)
 */
// Salvar no cache (memÃ³ria + AsyncStorage)
export const setCache = async (key, data, userId = null) => {
  try {
    const cacheKey = getCacheKey(key, userId);
    const cacheData = {
      data,
      timestamp: Date.now(),
    };
    
    // Cache em memÃ³ria (instantÃ¢neo)
    memoryCache.set(cacheKey, cacheData);
    
    // Cache persistente (AsyncStorage)
    await AsyncStorage.setItem(cacheKey, JSON.stringify(cacheData));
  } catch (error) {
    console.error('Erro ao salvar cache:', error);
  }
};

/**
 * Busca dados do cache (memÃ³ria primeiro, depois AsyncStorage)
 * @param {string} key - Chave do cache
 * @param {string|null} userId - ID do usuÃ¡rio (opcional)
 * @param {number} maxAge - Idade mÃ¡xima do cache em ms (opcional)
 * @returns {any|null} Dados do cache ou null se nÃ£o encontrado/expirado
 */
// Buscar do cache
export const getCache = async (key, userId = null, maxAge = CACHE_DURATION) => {
  try {
    const cacheKey = getCacheKey(key, userId);
    
    // Tentar buscar da memÃ³ria primeiro (mais rÃ¡pido)
    let cached = memoryCache.get(cacheKey);
    
    // Se nÃ£o estiver na memÃ³ria, buscar do AsyncStorage
    if (!cached) {
      const cachedStr = await AsyncStorage.getItem(cacheKey);
      if (cachedStr) {
        cached = JSON.parse(cachedStr);
        // Repovoar memÃ³ria
        memoryCache.set(cacheKey, cached);
      }
    }
    
    if (!cached) return null;
    
    // Verificar se o cache ainda Ã© vÃ¡lido
    const age = Date.now() - cached.timestamp;
    if (age > maxAge) {
      // Cache expirado
      memoryCache.delete(cacheKey);
      await AsyncStorage.removeItem(cacheKey);
      return null;
    }
    
    return cached.data;
  } catch (error) {
    console.error('Erro ao buscar cache:', error);
    return null;
  }
};

/**
 * Invalida cache especÃ­fico (remove da memÃ³ria e AsyncStorage)
 * @param {string} key - Chave do cache a ser invalidada
 * @param {string|null} userId - ID do usuÃ¡rio (opcional)
 */
// Invalidar cache especÃ­fico
export const invalidateCache = async (key, userId = null) => {
  try {
    const cacheKey = getCacheKey(key, userId);
    memoryCache.delete(cacheKey);
    await AsyncStorage.removeItem(cacheKey);
  } catch (error) {
    console.error('Erro ao invalidar cache:', error);
  }
};

/**
 * Limpa todo o cache (Ãºtil no logout)
 * @param {string|null} userId - ID do usuÃ¡rio (opcional)
 */
// Limpar todo o cache (Ãºtil no logout)
export const clearAllCache = async (userId = null) => {
  try {
    if (userId) {
      // Limpar cache especÃ­fico do usuÃ¡rio
      const keys = await AsyncStorage.getAllKeys();
      const userCacheKeys = keys.filter(k => k.startsWith(`cache_${userId}_`));
      await AsyncStorage.multiRemove(userCacheKeys);
      // Limpar memÃ³ria
      for (const [key] of memoryCache) {
        if (key.startsWith(`cache_${userId}_`)) {
          memoryCache.delete(key);
        }
      }
    } else {
      // Limpar todo cache
      memoryCache.clear();
      const keys = await AsyncStorage.getAllKeys();
      const cacheKeys = keys.filter(k => k.startsWith('cache_'));
      await AsyncStorage.multiRemove(cacheKeys);
    }
  } catch (error) {
    console.error('Erro ao limpar cache:', error);
  }
};

/**
 * PrÃ©-carrega dados essenciais em background apÃ³s login
 * Melhora performance carregando dados importantes antecipadamente
 * @param {string} userId - ID do usuÃ¡rio logado
 */
// PrÃ©-carregar dados essenciais (rodar no login)
export const preloadEssentialData = async (userId) => {
  try {
    console.log('ðŸš€ PrÃ©-carregando dados essenciais...');
    // Importar services aqui para evitar dependÃªncia circular
    const { getTrilhas } = require('./contentService');
    const { buscarDadosPerfil } = require('./userService');
    const { getUserStats } = require('./progressService');
    
    // Carregar em paralelo
    const [trilhas, perfil, stats] = await Promise.all([
      getTrilhas(),
      buscarDadosPerfil(userId),
      getUserStats(),
    ]);
    
    // Salvar no cache
    await Promise.all([
      setCache('trilhas', trilhas),
      setCache('perfil', perfil.success ? perfil.data : null, userId),
      setCache('stats', stats, userId),
    ]);
    
    console.log('âœ… Dados essenciais prÃ©-carregados!');
    return true;
  } catch (error) {
    console.error('Erro ao prÃ©-carregar dados:', error);
    return false;
  }
};

